z_income      = scale(inc_rev)[,1],
z_poverty     = scale(pov_rate)[,1],
z_65          = scale(share65)[,1],
z_noveh       = scale(nov_percapita)[,1],
vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# 安全标准化函数（避免 scale 出 NaN）
z_safe <- function(x) {
x <- as.numeric(x)
m <- mean(x, na.rm=TRUE)
s <- sd(x, na.rm=TRUE)
if (!is.finite(s) || s == 0) return(rep(0, length(x)))  # 全常数 → 0
(x - m) / s
}
# 构造 Vulnerability Index
tracts_attr <- tracts_attr %>%
mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
age65         = as.numeric(age65),
nov_hh        = as.numeric(nov_hh),
share65       = ifelse(pop_total > 0, age65 / pop_total, NA_real_),
nov_percapita = ifelse(pop_total > 0, nov_hh / pop_total, NA_real_),
inc_rev       = -median_income,  # 低收入 = 高脆弱
z_income      = z_safe(inc_rev),
z_poverty     = z_safe(pov_rate),
z_65          = z_safe(share65),
z_noveh       = z_safe(nov_percapita),
vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
# county
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
p1 <- ggplot(tracts_attr) +
geom_sf(aes(fill = vuln_index), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Tract Vulnerability Index (z-score composite)",
fill = "Index") +
theme_minimal()
p2 <- ggplot(tracts_attr) +
geom_sf(aes(fill = dist_hosp_km), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "Distance to Nearest Hospital (km)",
fill = "km") +
theme_minimal()
p3 <- ggplot(county_map) +
geom_sf(aes(fill = vuln_index_wt), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "County Vulnerability (population-weighted)",
fill = "Index") +
theme_minimal()
p4 <- ggplot(county_map) +
geom_sf(aes(fill = min_dist_hosp_km), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "County Minimum Distance to Hospital (km)",
fill = "km") +
theme_minimal()
(p1 + p2) / (p3 + p4)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# 安全标准化函数（避免 scale 出 NaN）
z_safe <- function(x) {
x <- as.numeric(x)
m <- mean(x, na.rm=TRUE)
s <- sd(x, na.rm=TRUE)
if (!is.finite(s) || s == 0) return(rep(0, length(x)))  # 全常数 → 0
(x - m) / s
}
# 构造 Vulnerability Index
tracts_attr <- tracts_attr %>%
mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
age65         = as.numeric(age65),
nov_hh        = as.numeric(nov_hh),
share65       = ifelse(pop_total > 0, age65 / pop_total, NA_real_),
nov_percapita = ifelse(pop_total > 0, nov_hh / pop_total, NA_real_),
inc_rev       = -median_income,  # 低收入 = 高脆弱
z_income      = z_safe(inc_rev),
z_poverty     = z_safe(pov_rate),
z_65          = z_safe(share65),
z_noveh       = z_safe(nov_percapita),
vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
# county
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
# 查看 county_name 和 vuln_index_wt 列
county_stats %>%
dplyr::select(county_name, vuln_index_wt)
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
tracts_attr <- tracts_attr %>%
mutate(
share65       = ifelse(pop_total > 0, age65 / pop_total, NA_real_),
nov_percapita = ifelse(pop_total > 0, nov_hh / pop_total, NA_real_),
inc_rev       = -median_income,             # reverse: lower income => higher vulnerability
z_income      = scale(inc_rev)[,1],
z_poverty     = scale(pov_rate)[,1],
z_65          = scale(share65)[,1],
z_noveh       = scale(nov_percapita)[,1],
vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
# 查看 county_name 和 vuln_index_wt 列
county_stats %>%
dplyr::select(county_name, vuln_index)
tracts_attr <- tracts_attr %>%
mutate(
share65       = ifelse(pop_total > 0, age65 / pop_total, NA_real_),
nov_percapita = ifelse(pop_total > 0, nov_hh / pop_total, NA_real_),
inc_rev       = -median_income,             # reverse: lower income => higher vulnerability
z_income      = scale(inc_rev)[,1],
z_poverty     = scale(pov_rate)[,1],
z_65          = scale(share65)[,1],
z_noveh       = scale(nov_percapita)[,1],
vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
tracts_attr %>%
dplyr::select(GEOID, vuln_index) %>%
head(10)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# county
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
# 查看 county_name 和 vuln_index_wt 列
county_stats %>%
dplyr::select(county_name, vuln_index_wt)
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
# 看每个县在计算 vuln_index_wt 时，x/w 的有效配对数量
diag_pairs <- tracts_in_cnty_num %>%
dplyr::mutate(
v_ok = is.finite(vuln_index),
w_ok = is.finite(pop_total) & pop_total > 0
) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_total   = dplyr::n(),
n_v_ok    = sum(v_ok),
n_w_ok    = sum(w_ok),
n_pair_ok = sum(v_ok & w_ok),
.groups = "drop"
) %>%
dplyr::arrange(n_pair_ok)
diag_pairs %>% dplyr::filter(county_name %in% c("Cambria","Cameron","Carbon","Centre","Chester"))
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# county
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
# 查看 county_name 和 vuln_index_wt 列
county_stats %>%
dplyr::select(county_name, vuln_index_wt)
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
# 看每个县在计算 vuln_index_wt 时，x/w 的有效配对数量
diag_pairs <- tracts_in_cnty_num %>%
dplyr::mutate(
v_ok = is.finite(vuln_index),
w_ok = is.finite(pop_total) & pop_total > 0
) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_total   = dplyr::n(),
n_v_ok    = sum(v_ok),
n_w_ok    = sum(w_ok),
n_pair_ok = sum(v_ok & w_ok),
.groups = "drop"
) %>%
dplyr::arrange(n_pair_ok)
diag_pairs %>% dplyr::filter(county_name %in% c("Cambria","Cameron","Carbon","Centre","Chester"))
# 以 "Chester" 为例（换成你想查的县名）
tracts_in_cnty_num %>%
dplyr::filter(county_name == "Chester") %>%
dplyr::select(GEOID, pop_total, vuln_index) %>%
head(20)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# 安全加权平均（同步过滤）
safe_wmean <- function(x, w) {
x <- as.numeric(x); w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
# ① 先算所有“用到权重向量 pop_total”的加权项
median_income_wt  = safe_wmean(.data$median_income, .data$pop_total),
pov_rate_wt       = safe_wmean(.data$pov_rate,      .data$pop_total),
share65_wt        = safe_wmean(.data$share65,       .data$pop_total),
nov_percapita_wt  = safe_wmean(.data$nov_percapita, .data$pop_total),
vuln_index_wt     = safe_wmean(.data$vuln_index,    .data$pop_total),
# ② 最后才汇总出“县级总人口”，并用不同列名以免遮蔽
pop_total_sum     = sum(.data$pop_total, na.rm = TRUE),
# ③ 其它标量统计
min_dist_hosp_km  = suppressWarnings(min(.data$dist_hosp_km, na.rm = TRUE)),
.groups = "drop"
)
# 查看 county_name 和 vuln_index_wt 列
county_stats %>%
dplyr::select(county_name, vuln_index_wt)
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
# 看每个县在计算 vuln_index_wt 时，x/w 的有效配对数量
diag_pairs <- tracts_in_cnty_num %>%
dplyr::mutate(
v_ok = is.finite(vuln_index),
w_ok = is.finite(pop_total) & pop_total > 0
) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_total   = dplyr::n(),
n_v_ok    = sum(v_ok),
n_w_ok    = sum(w_ok),
n_pair_ok = sum(v_ok & w_ok),
.groups = "drop"
) %>%
dplyr::arrange(n_pair_ok)
diag_pairs %>% dplyr::filter(county_name %in% c("Cambria","Cameron","Carbon","Centre","Chester"))
# 以 "Chester" 为例（换成你想查的县名）
tracts_in_cnty_num %>%
dplyr::filter(county_name == "Chester") %>%
dplyr::select(GEOID, pop_total, vuln_index) %>%
head(20)
p1 <- ggplot(tracts_attr) +
geom_sf(aes(fill = vuln_index), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Tract Vulnerability Index (z-score composite)",
fill = "Index") +
theme_minimal()
p2 <- ggplot(tracts_attr) +
geom_sf(aes(fill = dist_hosp_km), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "Distance to Nearest Hospital (km)",
fill = "km") +
theme_minimal()
p3 <- ggplot(county_map) +
geom_sf(aes(fill = vuln_index_wt), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "County Vulnerability (population-weighted)",
fill = "Index") +
theme_minimal()
p4 <- ggplot(county_map) +
geom_sf(aes(fill = min_dist_hosp_km), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "County Minimum Distance to Hospital (km)",
fill = "km") +
theme_minimal()
(p1 + p2) / (p3 + p4)
#| echo: true
# Packages
required_pkgs <- c(
"tidyverse","sf","tigris","tidycensus","units","nngeo",
"ggplot2","scales","janitor","glue","patchwork","osmdata"
)
for (p in required_pkgs) {
if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(p, character.only = TRUE)
}
options(tigris_use_cache = TRUE, tigris_class = "sf")
# --- PARAMETERS ---
state_abbr <- "PA"
state_name <- "Pennsylvania"
# Use ACS 5-year for small-area reliability
year_acs <- 2022
survey  <- "acs5"
# If your CENSUS_API_KEY is not installed, uncomment and add your key:
tidycensus::census_api_key("547c6d8007c794850c2b25b34f1ce85befe8ab09", install = TRUE, overwrite = TRUE)
# Counties & tracts (geometry)
counties <- tigris::counties(state = state_abbr, year = 2023, cb = TRUE) %>%
st_transform(5070)  # NAD83 / Conus Albers for distance/area
tracts  <- tigris::tracts(state = state_abbr, year = 2023, cb = TRUE) %>%
st_transform(5070)
glue("Counties: {nrow(counties)}; Tracts: {nrow(tracts)}")
# ---- Step 1 answers ----
# Hospitals count
n_hosp <- nrow(hospitals)
# Tracts count
n_tracts <- nrow(tracts)
# CRS report
crs_counties <- st_crs(counties)$input
crs_tracts   <- st_crs(tracts)$input
crs_hosp     <- st_crs(hospitals)$input
glue::glue("
Step 1 — Answers
- Hospitals in dataset: {n_hosp}
- Census tracts: {n_tracts}
- CRS (counties): {crs_counties}
- CRS (tracts):   {crs_tracts}
- CRS (hospitals): {crs_hosp}
")
