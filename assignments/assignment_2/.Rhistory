tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,   # 或者 join = sf::st_intersects
left = TRUE
# largest = TRUE        # 如果出现一对多可打开（sf >= 1.0.8 支持）
)
# 快速自检：看看 county_name 是否真的进来了、是否有 NA
# table(is.na(tracts_in_cnty$county_name))
# 4) 县级汇总：按我们刚刚明确命名的 county_name 分组
county_stats <- tracts_in_cnty %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
pop_total        = sum(pop_total, na.rm = TRUE),
median_income_wt = stats::weighted.mean(median_income, pop_total, na.rm = TRUE),
pov_rate_wt      = stats::weighted.mean(pov_rate, pop_total, na.rm = TRUE),
share65_wt       = stats::weighted.mean(share65, pop_total, na.rm = TRUE),
nov_percapita_wt = stats::weighted.mean(nov_percapita, pop_total, na.rm = TRUE),
vuln_index_wt    = stats::weighted.mean(vuln_index, pop_total, na.rm = TRUE),
min_dist_hosp_km = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
# Spatial join tract -> county
# 安全加权平均：同步过滤 x 和 w 的有效值（都是有限数，且权重>0）
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# 确保 CRS 一致（若已一致可省略）
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# 只带入不会冲突的县字段，改名为 county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# 空间连接（tract ∈ county）
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# 在 group_by 之前，把会参与计算的列都强制为 numeric，避免 list/units
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# 县级汇总：用 safe_wmean 避免 x 和 w 长度不一致
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
# 并回县图层
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
p1 <- ggplot(tracts_attr) +
geom_sf(aes(fill = vuln_index), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Tract Vulnerability Index (z-score composite)",
fill = "Index") +
theme_minimal()
p2 <- ggplot(tracts_attr) +
geom_sf(aes(fill = dist_hosp_km), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "Distance to Nearest Hospital (km)",
fill = "km") +
theme_minimal()
p3 <- ggplot(county_map) +
geom_sf(aes(fill = vuln_index_wt), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "County Vulnerability (population-weighted)",
fill = "Index") +
theme_minimal()
p4 <- ggplot(county_map) +
geom_sf(aes(fill = min_dist_hosp_km), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "County Minimum Distance to Hospital (km)",
fill = "km") +
theme_minimal()
(p1 + p2) / (p3 + p4)
#| echo: true
# Packages
required_pkgs <- c(
"tidyverse","sf","tigris","tidycensus","units","nngeo",
"ggplot2","scales","janitor","glue","patchwork","osmdata"
)
for (p in required_pkgs) {
if (!requireNamespace(p, quietly = TRUE)) install.packages(p)
library(p, character.only = TRUE)
}
options(tigris_use_cache = TRUE, tigris_class = "sf")
# --- PARAMETERS ---
state_abbr <- "PA"
state_name <- "Pennsylvania"
# Use ACS 5-year for small-area reliability
year_acs <- 2022
survey  <- "acs5"
# If your CENSUS_API_KEY is not installed, uncomment and add your key:
# tidycensus::census_api_key("YOUR_KEY_HERE", install = TRUE, overwrite = TRUE)
# Counties & tracts (geometry)
counties <- tigris::counties(state = state_abbr, year = 2023, cb = TRUE) %>%
st_transform(5070)  # NAD83 / Conus Albers for distance/area
tracts  <- tigris::tracts(state = state_abbr, year = 2023, cb = TRUE) %>%
st_transform(5070)
glue("Counties: {nrow(counties)}; Tracts: {nrow(tracts)}")
vars <- c(
median_income = "B19013_001",
pop_total     = "B01003_001",
# 65+
male_65_66    = "B01001_020",
male_67_69    = "B01001_021",
female_65_66  = "B01001_044",
female_67_69  = "B01001_045",
# poverty
pov_universe  = "B17001_001",
pov_below     = "B17001_002",
# no vehicle (owner & renter occupied HHs)
nov_owner     = "B25044_003",
nov_renter    = "B25044_010"
)
#
tract_acs <- get_acs(
geography = "tract",
state = state_abbr,
variables = vars,
year = year_acs,
survey = survey,
geometry = FALSE,
cache_table = TRUE,
output = "wide"
)
#
tract_attr <- tract_acs %>%
dplyr::transmute(
GEOID,
median_income = median_incomeE,
pop_total     = pop_totalE,
age65         = male_65_66E + male_67_69E + female_65_66E + female_67_69E,
pov_rate      = ifelse(pov_universeE > 0, pov_belowE / pov_universeE, NA_real_),
nov_hh        = nov_ownerE + nov_renterE
)
#
tracts_attr <- tracts %>%
dplyr::left_join(tract_attr, by = "GEOID")
# Query OSM for hospitals within Pennsylvania bounding box
pa_bbox <- st_transform(counties, 4326) %>% st_bbox()
q <- opq(bbox = c(pa_bbox["xmin"], pa_bbox["ymin"], pa_bbox["xmax"], pa_bbox["ymax"])) %>%
add_osm_feature(key = "amenity", value = "hospital")
osm_h <- osmdata_sf(q)
hospitals <- osm_h$osm_points %>%
st_transform(5070) %>%
st_intersection(st_union(counties)) %>%
mutate(name = coalesce(name, "Unknown hospital")) %>%
distinct(geometry, .keep_all = TRUE)
glue("Hospitals found (points): {nrow(hospitals)}")
# Centroids (use within for compact tracts; for complex shapes you may consider population-weighted centroids)
tract_cent <- st_point_on_surface(tracts_attr)
# Nearest neighbor (index + distance)
nn <- nngeo::st_nn(tract_cent, hospitals, k = 1, returnDist = TRUE)
# Distances are in meters because EPSG:5070 is projected in meters
dist_m <- sapply(nn$dist, function(x) ifelse(length(x)==0, NA_real_, x[1]))
tracts_attr <- tracts_attr %>%
mutate(
dist_hosp_m = dist_m,
dist_hosp_km = set_units(dist_hosp_m, "m") %>% set_units("km") %>% drop_units()
)
summary(tracts_attr$dist_hosp_km)
tracts_attr <- tracts_attr %>%
mutate(
share65       = ifelse(pop_total > 0, age65 / pop_total, NA_real_),
nov_percapita = ifelse(pop_total > 0, nov_hh / pop_total, NA_real_),
inc_rev       = -median_income,             # reverse: lower income => higher vulnerability
z_income      = scale(inc_rev)[,1],
z_poverty     = scale(pov_rate)[,1],
z_65          = scale(share65)[,1],
z_noveh       = scale(nov_percapita)[,1],
vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# safe_wmean
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
# 1) 看 county_stats 里到底有没有这一列 & NA 比例
names(county_stats)
mean(is.na(county_stats$vuln_index_wt))
# 2) 在汇总前检查 tract 级是否有值
mean(is.na(tracts_attr$vuln_index))            # tract 层
mean(is.na(tracts_in_cnty$county_name))        # 是否都分到县
# 3) 每县有效成对样本数（既有 x 也有权重）
tracts_in_cnty %>%
dplyr::mutate(
vuln_index = as.numeric(vuln_index),
pop_total  = as.numeric(pop_total)
) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(n_pair = sum(is.finite(vuln_index) & is.finite(pop_total) & pop_total > 0)) %>%
dplyr::arrange(n_pair) %>%
head()
p1 <- ggplot(tracts_attr) +
geom_sf(aes(fill = vuln_index), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Tract Vulnerability Index (z-score composite)",
fill = "Index") +
theme_minimal()
p2 <- ggplot(tracts_attr) +
geom_sf(aes(fill = dist_hosp_km), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "Distance to Nearest Hospital (km)",
fill = "km") +
theme_minimal()
p3 <- ggplot(county_map) +
geom_sf(aes(fill = vuln_index_wt), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "County Vulnerability (population-weighted)",
fill = "Index") +
theme_minimal()
p4 <- ggplot(county_map) +
geom_sf(aes(fill = min_dist_hosp_km), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "County Minimum Distance to Hospital (km)",
fill = "km") +
theme_minimal()
(p1 + p2) / (p3 + p4)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# county
safe_wmean <- function(x, w) {
x <- as.numeric(x); w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
county_stats <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
p1 <- ggplot(tracts_attr) +
geom_sf(aes(fill = vuln_index), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Tract Vulnerability Index (z-score composite)",
fill = "Index") +
theme_minimal()
p2 <- ggplot(tracts_attr) +
geom_sf(aes(fill = dist_hosp_km), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "Distance to Nearest Hospital (km)",
fill = "km") +
theme_minimal()
p3 <- ggplot(county_map) +
geom_sf(aes(fill = vuln_index_wt), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "County Vulnerability (population-weighted)",
fill = "Index") +
theme_minimal()
p4 <- ggplot(county_map) +
geom_sf(aes(fill = min_dist_hosp_km), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "County Minimum Distance to Hospital (km)",
fill = "km") +
theme_minimal()
(p1 + p2) / (p3 + p4)
# 全州层面：tract 脆弱性是否有效
mean(is.finite(tracts_attr$vuln_index))         # 期望是 >0.9
# 县层面：每县有效样本数（应该大多 > 0）
tracts_in_cnty %>%
dplyr::mutate(v = is.finite(vuln_index),
w = is.finite(pop_total) & pop_total > 0) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(n_pair = sum(v & w), .groups="drop") %>%
dplyr::arrange(n_pair) %>%
print(n = 10)
# 哪些县在汇总后仍是 NA（如果有就是这些县在上一步 n_pair==0）
which_na <- county_stats %>% dplyr::filter(!is.finite(vuln_index_wt)) %>% dplyr::pull(county_name)
which_na
# ① county_map 里到底有没有这列？是否全 NA？
names(county_map)
summary(county_map$vuln_index_wt)
mean(is.na(county_map$vuln_index_wt))  # 如果接近 1，就是全 NA
# ② county_stats 里列名对不对？（有时会叫 vuln_index_wt.x / .y）
names(county_stats)
# ③ 看看有多少县在“有效成对样本”（vuln_index 有效 且 pop_total>0）为 0
tracts_in_cnty %>%
dplyr::mutate(v= is.finite(as.numeric(vuln_index)),
w= is.finite(as.numeric(pop_total)) & as.numeric(pop_total) > 0) %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(n_pair=sum(v & w), .groups="drop") %>%
dplyr::arrange(n_pair) %>%
print(n=10)
z_safe <- function(x) {
x <- as.numeric(x)
m <- mean(x, na.rm=TRUE); s <- stats::sd(x, na.rm=TRUE)
if (!is.finite(s) || s==0) return(rep(0, length(x)))  # 全常数→全 0
(x - m)/s
}
tracts_attr <- tracts_attr %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
age65         = as.numeric(age65),
nov_hh        = as.numeric(nov_hh),
share65       = dplyr::if_else(pop_total > 0, age65 / pop_total, NA_real_),
nov_percapita = dplyr::if_else(pop_total > 0, nov_hh / pop_total, NA_real_),
inc_rev       = -median_income,  # 低收入→高脆弱
z_income  = z_safe(inc_rev),
z_poverty = z_safe(pov_rate),
z_65      = z_safe(share65),
z_noveh   = z_safe(nov_percapita),
vuln_index = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)
)
# Spatial join tract -> county
#
safe_wmean <- function(x, w) {
x <- as.numeric(x)
w <- as.numeric(w)
idx <- is.finite(x) & is.finite(w) & w > 0
if (!any(idx)) return(NA_real_)
stats::weighted.mean(x[idx], w[idx])
}
# CRS
counties <- sf::st_transform(counties, sf::st_crs(tracts_attr))
# county_name
cnty_keep <- counties %>%
dplyr::select(COUNTYFP, county_name = NAME)
# tract ∈ county
tracts_in_cnty <- sf::st_join(
tracts_attr,
cnty_keep,
join = sf::st_within,
left = TRUE
)
# numeric
tracts_in_cnty_num <- tracts_in_cnty %>%
dplyr::mutate(
pop_total     = as.numeric(pop_total),
median_income = as.numeric(median_income),
pov_rate      = as.numeric(pov_rate),
share65       = as.numeric(share65),
nov_percapita = as.numeric(nov_percapita),
vuln_index    = as.numeric(vuln_index),
dist_hosp_km  = as.numeric(dist_hosp_km)
)
# county
county_stats <- tracts_in_cnty_num %>%
sf::st_drop_geometry() %>%
dplyr::group_by(county_name) %>%
dplyr::summarise(
n_tracts          = dplyr::n(),
pop_total         = sum(pop_total, na.rm = TRUE),
median_income_wt  = safe_wmean(median_income, pop_total),
pov_rate_wt       = safe_wmean(pov_rate, pop_total),
share65_wt        = safe_wmean(share65, pop_total),
nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),
vuln_index_wt     = safe_wmean(vuln_index, pop_total),
min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))
) %>%
dplyr::ungroup()
#
county_map <- counties %>%
dplyr::left_join(county_stats, by = c("NAME" = "county_name"))
p1 <- ggplot(tracts_attr) +
geom_sf(aes(fill = vuln_index), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "Tract Vulnerability Index (z-score composite)",
fill = "Index") +
theme_minimal()
p2 <- ggplot(tracts_attr) +
geom_sf(aes(fill = dist_hosp_km), color = NA) +
geom_sf(data = st_union(counties), fill = NA, color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "Distance to Nearest Hospital (km)",
fill = "km") +
theme_minimal()
p3 <- ggplot(county_map) +
geom_sf(aes(fill = vuln_index_wt), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "magma", na.value = "grey90") +
labs(title = "County Vulnerability (population-weighted)",
fill = "Index") +
theme_minimal()
p4 <- ggplot(county_map) +
geom_sf(aes(fill = min_dist_hosp_km), color = "white", linewidth = 0.2) +
scale_fill_viridis_c(option = "plasma", labels = scales::number_format(accuracy = 0.1), na.value = "grey90") +
labs(title = "County Minimum Distance to Hospital (km)",
fill = "km") +
theme_minimal()
(p1 + p2) / (p3 + p4)
