{
  "hash": "aef19941f087b81604bf96045f4b4e7a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Assignment 2: Spatial Analysis and Visualization\"\nsubtitle: \"Healthcare Access and Equity in Pennsylvania\"\nauthor: \"Zicheng Xiang\"\ndate: today\nformat: \n  html:\n    code-fold: true\n    toc: true\n    toc-location: left\n    theme: cosmo\n    embed-resources: true\nexecute:\n  warning: false\n  message: false\n---\n\n# Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| echo: true\n\n# Packages\nrequired_pkgs <- c(\n  \"tidyverse\",\"sf\",\"tigris\",\"tidycensus\",\"units\",\"nngeo\",\n  \"ggplot2\",\"scales\",\"janitor\",\"glue\",\"patchwork\",\"osmdata\"\n)\n\nfor (p in required_pkgs) {\n  if (!requireNamespace(p, quietly = TRUE)) install.packages(p)\n  library(p, character.only = TRUE)\n}\n\noptions(tigris_use_cache = TRUE, tigris_class = \"sf\")\n\n# --- PARAMETERS ---\nstate_abbr <- \"PA\"\nstate_name <- \"Pennsylvania\"\n\n# Use ACS 5-year for small-area reliability\nyear_acs <- 2022\nsurvey  <- \"acs5\"\n\n# If your CENSUS_API_KEY is not installed, uncomment and add your key:\n# tidycensus::census_api_key(\"YOUR_KEY_HERE\", install = TRUE, overwrite = TRUE)\n```\n:::\n\n\n# Data dictionary\n\nWe will use the following ACS variables (5-year) for tract-level vulnerability:\n\n- `B19013_001`: Median household income (USD)\n- `B01001_020`, `B01001_021`, `B01001_044`, `B01001_045`: Population age 65+ (sex by age)\n- `B17001_001`, `B17001_002`: Poverty universe and below-poverty\n- `B25044_003`, `B25044_010`: No vehicle available (owner & renter occupied)\n- `B01003_001`: Total population\n\n# 1) Load geographies\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Counties & tracts (geometry)\ncounties <- tigris::counties(state = state_abbr, year = 2023, cb = TRUE) %>%\n  st_transform(5070)  # NAD83 / Conus Albers for distance/area\n\ntracts  <- tigris::tracts(state = state_abbr, year = 2023, cb = TRUE) %>%\n  st_transform(5070)\n\nglue(\"Counties: {nrow(counties)}; Tracts: {nrow(tracts)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCounties: 67; Tracts: 3445\n```\n\n\n:::\n:::\n\n\n# 2) Pull ACS attributes (tract-level)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvars <- c(\n  median_income = \"B19013_001\",\n  pop_total     = \"B01003_001\",\n  # 65+\n  male_65_66    = \"B01001_020\",\n  male_67_69    = \"B01001_021\",\n  female_65_66  = \"B01001_044\",\n  female_67_69  = \"B01001_045\",\n  # poverty\n  pov_universe  = \"B17001_001\",\n  pov_below     = \"B17001_002\",\n  # no vehicle (owner & renter occupied HHs)\n  nov_owner     = \"B25044_003\",\n  nov_renter    = \"B25044_010\"\n)\n\n# 不做 clean_names，直接使用 E/M 列\ntract_acs <- get_acs(\n  geography = \"tract\",\n  state = state_abbr,\n  variables = vars,\n  year = year_acs,\n  survey = survey,\n  geometry = FALSE,\n  cache_table = TRUE,\n  output = \"wide\"\n)\n\n# 用 …E 列名\ntract_attr <- tract_acs %>%\n  dplyr::transmute(\n    GEOID,\n    median_income = median_incomeE,\n    pop_total     = pop_totalE,\n    age65         = male_65_66E + male_67_69E + female_65_66E + female_67_69E,\n    pov_rate      = ifelse(pov_universeE > 0, pov_belowE / pov_universeE, NA_real_),\n    nov_hh        = nov_ownerE + nov_renterE\n  )\n\n# Join 到几何\ntracts_attr <- tracts %>%\n  dplyr::left_join(tract_attr, by = \"GEOID\")\n```\n:::\n\n\n# 3) Hospitals from OpenStreetMap (live download)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Query OSM for hospitals within Pennsylvania bounding box\npa_bbox <- st_transform(counties, 4326) %>% st_bbox()\n\nq <- opq(bbox = c(pa_bbox[\"xmin\"], pa_bbox[\"ymin\"], pa_bbox[\"xmax\"], pa_bbox[\"ymax\"])) %>%\n  add_osm_feature(key = \"amenity\", value = \"hospital\")\n\nosm_h <- osmdata_sf(q)\n\nhospitals <- osm_h$osm_points %>%\n  st_transform(5070) %>%\n  st_intersection(st_union(counties)) %>%\n  mutate(name = coalesce(name, \"Unknown hospital\")) %>%\n  distinct(geometry, .keep_all = TRUE)\n\nglue(\"Hospitals found (points): {nrow(hospitals)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nHospitals found (points): 5638\n```\n\n\n:::\n:::\n\n\n> If your environment cannot access OSM, you may substitute a local hospital dataset. The rest of the workflow is unchanged.\n\n# 4) Accessibility: distance from tract centroid to nearest hospital\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Centroids (use within for compact tracts; for complex shapes you may consider population-weighted centroids)\ntract_cent <- st_point_on_surface(tracts_attr)\n\n# Nearest neighbor (index + distance)\nnn <- nngeo::st_nn(tract_cent, hospitals, k = 1, returnDist = TRUE)\n\n# Distances are in meters because EPSG:5070 is projected in meters\ndist_m <- sapply(nn$dist, function(x) ifelse(length(x)==0, NA_real_, x[1]))\n\ntracts_attr <- tracts_attr %>%\n  mutate(\n    dist_hosp_m = dist_m,\n    dist_hosp_km = set_units(dist_hosp_m, \"m\") %>% set_units(\"km\") %>% drop_units()\n  )\nsummary(tracts_attr$dist_hosp_km)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     Min.   1st Qu.    Median      Mean   3rd Qu.      Max. \n 0.003141  1.608247  3.458952  5.927695  8.169082 51.890854 \n```\n\n\n:::\n:::\n\n\n# 5) Vulnerability index (simple standardized composite)\n\nWe define a composite **Vulnerability Index** at the tract level using z-scores for:\n- Lower median income (reverse coded)\n- Higher poverty rate\n- Higher 65+ share\n- Higher no-vehicle households per capita\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntracts_attr <- tracts_attr %>%\n  mutate(\n    share65       = ifelse(pop_total > 0, age65 / pop_total, NA_real_),\n    nov_percapita = ifelse(pop_total > 0, nov_hh / pop_total, NA_real_),\n    inc_rev       = -median_income,             # reverse: lower income => higher vulnerability\n    z_income      = scale(inc_rev)[,1],\n    z_poverty     = scale(pov_rate)[,1],\n    z_65          = scale(share65)[,1],\n    z_noveh       = scale(nov_percapita)[,1],\n    vuln_index    = rowMeans(cbind(z_income, z_poverty, z_65, z_noveh), na.rm = TRUE)\n  )\n```\n:::\n\n\n# 6) County-level aggregation\n\nWe compute county summaries weighted by tract population (for rates and indices) and simple minimum distance for access.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Spatial join tract -> county\n# 安全加权平均：同步过滤 x 和 w 的有效值（都是有限数，且权重>0）\nsafe_wmean <- function(x, w) {\n  x <- as.numeric(x)\n  w <- as.numeric(w)\n  idx <- is.finite(x) & is.finite(w) & w > 0\n  if (!any(idx)) return(NA_real_)\n  stats::weighted.mean(x[idx], w[idx])\n}\n\n# 确保 CRS 一致（若已一致可省略）\ncounties <- sf::st_transform(counties, sf::st_crs(tracts_attr))\n\n# 只带入不会冲突的县字段，改名为 county_name\ncnty_keep <- counties %>%\n  dplyr::select(COUNTYFP, county_name = NAME)\n\n# 空间连接（tract ∈ county）\ntracts_in_cnty <- sf::st_join(\n  tracts_attr,\n  cnty_keep,\n  join = sf::st_within,\n  left = TRUE\n)\n\n# 在 group_by 之前，把会参与计算的列都强制为 numeric，避免 list/units\ntracts_in_cnty_num <- tracts_in_cnty %>%\n  dplyr::mutate(\n    pop_total     = as.numeric(pop_total),\n    median_income = as.numeric(median_income),\n    pov_rate      = as.numeric(pov_rate),\n    share65       = as.numeric(share65),\n    nov_percapita = as.numeric(nov_percapita),\n    vuln_index    = as.numeric(vuln_index),\n    dist_hosp_km  = as.numeric(dist_hosp_km)\n  )\n\n# 县级汇总：用 safe_wmean 避免 x 和 w 长度不一致\ncounty_stats <- tracts_in_cnty_num %>%\n  sf::st_drop_geometry() %>%\n  dplyr::group_by(county_name) %>%\n  dplyr::summarise(\n    n_tracts          = dplyr::n(),\n    pop_total         = sum(pop_total, na.rm = TRUE),\n    median_income_wt  = safe_wmean(median_income, pop_total),\n    pov_rate_wt       = safe_wmean(pov_rate, pop_total),\n    share65_wt        = safe_wmean(share65, pop_total),\n    nov_percapita_wt  = safe_wmean(nov_percapita, pop_total),\n    vuln_index_wt     = safe_wmean(vuln_index, pop_total),\n    min_dist_hosp_km  = suppressWarnings(min(dist_hosp_km, na.rm = TRUE))\n  ) %>%\n  dplyr::ungroup()\n\n# 并回县图层\ncounty_map <- counties %>%\n  dplyr::left_join(county_stats, by = c(\"NAME\" = \"county_name\"))\n```\n:::\n\n\n# 7) Maps\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(tracts_attr) +\n  geom_sf(aes(fill = vuln_index), color = NA) +\n  geom_sf(data = st_union(counties), fill = NA, color = \"white\", linewidth = 0.2) +\n  scale_fill_viridis_c(option = \"magma\", na.value = \"grey90\") +\n  labs(title = \"Tract Vulnerability Index (z-score composite)\",\n       fill = \"Index\") +\n  theme_minimal()\n\np2 <- ggplot(tracts_attr) +\n  geom_sf(aes(fill = dist_hosp_km), color = NA) +\n  geom_sf(data = st_union(counties), fill = NA, color = \"white\", linewidth = 0.2) +\n  scale_fill_viridis_c(option = \"plasma\", labels = scales::number_format(accuracy = 0.1), na.value = \"grey90\") +\n  labs(title = \"Distance to Nearest Hospital (km)\",\n       fill = \"km\") +\n  theme_minimal()\n\np3 <- ggplot(county_map) +\n  geom_sf(aes(fill = vuln_index_wt), color = \"white\", linewidth = 0.2) +\n  scale_fill_viridis_c(option = \"magma\", na.value = \"grey90\") +\n  labs(title = \"County Vulnerability (population-weighted)\",\n       fill = \"Index\") +\n  theme_minimal()\n\np4 <- ggplot(county_map) +\n  geom_sf(aes(fill = min_dist_hosp_km), color = \"white\", linewidth = 0.2) +\n  scale_fill_viridis_c(option = \"plasma\", labels = scales::number_format(accuracy = 0.1), na.value = \"grey90\") +\n  labs(title = \"County Minimum Distance to Hospital (km)\",\n       fill = \"km\") +\n  theme_minimal()\n\n(p1 + p2) / (p3 + p4)\n```\n\n::: {.cell-output-display}\n![](assignment2_completed_files/figure-html/maps-1.png){width=960}\n:::\n:::\n\n\n# 8) Findings (brief)\n\n- **Coverage:** Most Pennsylvania tracts have at least one hospital within a short driving distance; rural tracts show longer distances.\n- **Vulnerability:** Higher vulnerability clusters where incomes are lower, elderly share is higher, poverty is higher, and households lack vehicles.\n- **County rollups:** County-level population-weighted indices smooth tract variation but still highlight regional disparities.\n\n# 9) Reproducibility notes\n\n- CRS: All spatial analysis is performed in **EPSG:5070** (meters). Input layers are transformed on load.\n- Data sources: ACS 5-year via `tidycensus`; tracts/counties via TIGER (`tigris`); hospitals from OSM via `osmdata` (amenity=hospital).\n- Replace OSM with other hospital datasets if required by your assignment rubric; only the point layer used for nearest-neighbor distances is needed.\n- Randomness: None.\n",
    "supporting": [
      "assignment2_completed_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}